#!/usr/bin/env sh
set -eu

usage() {
  echo "Usage: $0 <username> <password>" >&2
  exit 2
}

if [ "${1-}" = "" ] || [ "${2-}" = "" ]; then
  usage
fi

USERNAME="$1"
PASSWORD="$2"

SCRIPT_DIR="$(CDPATH= cd -- "$(dirname -- "$0")" && pwd)"
PROJECT_DIR="$(CDPATH= cd -- "$SCRIPT_DIR/.." && pwd)"
ENV_FILE="$PROJECT_DIR/.env"

if ! command -v openssl >/dev/null 2>&1; then
  echo "Error: missing 'openssl'. Install it and re-run." >&2
  exit 1
fi

NEXTAUTH_SECRET="$(openssl rand -hex 32)"

PASSWORD_HASH=""

# Prefer system htpasswd (bcrypt) when available (common on Debian/Ubuntu/Raspberry Pi).
# Install: sudo apt-get update && sudo apt-get install -y apache2-utils
if ! command -v htpasswd >/dev/null 2>&1; then
  echo "Error: missing 'htpasswd' (apache2-utils). Install it and re-run." >&2
  exit 1
fi

# -n: no file, -b: batch (password from CLI), -B: bcrypt, -C: cost
# Use an empty username; we only need the hash after ':'
PASSWORD_HASH="$(htpasswd -bnBC 10 "" "$PASSWORD" | cut -d: -f2 | tr -d '\r\n')"

# Some generators output "$2y$" hashes; normalize for broad compatibility.
PASSWORD_HASH="$(printf '%s' "$PASSWORD_HASH" | sed 's/^\$2y\$/\$2b\$/')"

# Escape "$" to "$$" so Docker Compose doesn't try to interpolate the hash as variables.
# (e.g. $2b$10$Abc... -> $$2b$$10$$Abc...)
PASSWORD_HASH="$(printf '%s' "$PASSWORD_HASH" | sed 's/\$/\$\$/g')"

# Write .env (Docker Compose loads it automatically from the project directory).
# Use restrictive permissions when possible.
{
  echo "# Generated by setup/generate-admin-login.sh"
  echo "ADMIN_PANEL_USERNAME=$USERNAME"
  echo "ADMIN_PANEL_PASSWORD_HASH=$PASSWORD_HASH"
  echo "NEXTAUTH_SECRET=$NEXTAUTH_SECRET"
} > "$ENV_FILE"

chmod 600 "$ENV_FILE" 2>/dev/null || true

echo "Wrote $ENV_FILE"
echo "- ADMIN_PANEL_USERNAME=$USERNAME"
echo "- ADMIN_PANEL_PASSWORD_HASH=<bcrypt>"
echo "- NEXTAUTH_SECRET=<generated>"
echo ""
echo "Next: from $PROJECT_DIR run: docker compose up -d"
